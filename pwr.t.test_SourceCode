# Source Code: pwr.t.test()
# Obtained using edit(pwr.t.test) [need to load pwr library first]
# Date: Dec. 9th, 2021





## Function pwr.t.test(): compute power of tests or determine parameters to obtain target power (similar to power.t.test). 

## Parameters:

# n: sample size (per group).

# d: effect size (Cohen's d) - difference between the means divided by the pooled standard deviation. 

# sig.level: significance level (Type I Error Probability).

# power: power of test (1-Type II Error Probability).

# type: type of t test: one- two- or paired-samples. 

# alternative: a character string specifying the alternative hypothesis, must be one of "two.sided" (default), "greater", or "less".


## Details:
# Exactly one of the 4 parameters d, n, power, and sig.level must be passed as NULL, and that paramter is determined from the others. 

# Parameter sig.level has a default value: sig.level = 0.05. 


function(n = NULL, d = NULL, sig.level = 0.05, power = NULL, 
          type = c("two.sample", "one.sample", "paired"), alternative = c("two.sided", 
                                                                          "less", "greater")) 
                                                                        
                                                                          
{
  # Check if at least one of the 4 parameters d, n, power, and sig.level is NULL.
  if (sum(sapply(list(n, d, power, sig.level), is.null)) != 
      1) 
    stop("exactly one of n, d, power, and sig.level must be NULL")
    
  # Parameter d can be given as strings "small", "medium", "large".
  # In this case, d will be the conventional effect size for the t test of that size (i.e. small, medium, large). 
  # small -> d = 0.2; medium -> d = 0.5; large -> d = 0.8.
  
  if (!is.null(d) && is.character(d)) 
    d <- cohen.ES(test = "t", size = d)$effect.size
  
  
  # Check sig.level entered is valid (i.e. not NULL, is numeric, and is between [0, 1])
  if (!is.null(sig.level) && !is.numeric(sig.level) || any(0 > 
                                                           sig.level | sig.level > 1)) 
    stop(sQuote("sig.level"), " must be numeric in [0, 1]")
  
  
  # Check power entered is valid (i.e. not NULL, is numeric, and is between [0, 1])
  if (!is.null(power) && !is.numeric(power) || any(0 > power | 
                                                   power > 1)) 
    stop(sQuote("power"), " must be numeric in [0, 1]")
  
  # Check if the parameter type entered is valid (i.e. matches one of "one.sample", "two.sample", "paired")
  type <- match.arg(type)
  
  # Check if the parameter alternative entered is valid (i.e. matches one of "two.sided", "greater", "less")
  alternative <- match.arg(alternative)
  
  # Assign values 1, 2, 1 to the three different types.
  # Note: the t-test procedure for one.sample is the same for the paired. 
  
  # Switch according to type argument.
  tsample <- switch(type, one.sample = 1, two.sample = 2, 
                    paired = 1)
                    
  # Switch according to alternative argument.
  # This variable is used to distinguish the three types of alternative hypothesis. 
  ttside <- switch(alternative, less = 1, two.sided = 2, greater = 3)
  
  # Switch according to alternative argument. 
  # This variable is used to determine whether the significance level needs to be divided by two (e.g. alpha or alpha/2).
  tside <- switch(alternative, less = 1, two.sided = 2, greater = 1)
  
  # If it's a two-sided test and the effect size is not null, make the effect size equal to its absolute value. 
  if (tside == 2 && !is.null(d)) 
    d <- abs(d)
  
  # If it's a one sided less than test, 
  if (ttside == 1) {
  
    # p.body is the power function. 
    
    p.body <- quote({
      # This is degrees of freedom, one sample df = (n-1), two sample df = 2(n-1).
      nu <- (n - 1) * tsample
      
      # ncp for one sample test: sqrt(n/1)*d = sqrt(n)*(mu1-mu0)/sigma. 
      
      # ncp for two sample test: sqrt(n/2)*d = sqrt(n/2)(mu1-mu0)/sigma. 
      pt(qt(sig.level/tside, nu, lower = TRUE), nu, ncp = sqrt(n/tsample) * d, lower = TRUE)
    })
  }
  if (ttside == 2) {
    p.body <- quote({
      nu <- (n - 1) * tsample
      qu <- qt(sig.level/tside, nu, lower = FALSE)
      
     
      pt(qu, nu, ncp = sqrt(n/tsample) * d, lower = FALSE) + 
        pt(-qu, nu, ncp = sqrt(n/tsample) * d, lower = TRUE)
    })
  }
  if (ttside == 3) {
    p.body <- quote({
      nu <- (n - 1) * tsample
      pt(qt(sig.level/tside, nu, lower = FALSE), nu, ncp = sqrt(n/tsample) * 
           d, lower = FALSE)
    })
  }
  if (is.null(power)) 
    power <- eval(p.body)
  else if (is.null(n)) 
  
    # Solve the function power function - power = 0 for n between 2+1e-10 to 1e+09. 
    n <- uniroot(function(n) eval(p.body) - power, c(2 + 
                                                       1e-10, 1e+09))$root
  else if (is.null(d)) {
    if (ttside == 2) 
      d <- uniroot(function(d) eval(p.body) - power, c(1e-07, 
                                                       10))$root
    if (ttside == 1) 
      d <- uniroot(function(d) eval(p.body) - power, c(-10, 
                                                       5))$root
    if (ttside == 3) 
      d <- uniroot(function(d) eval(p.body) - power, c(-5, 
                                                       10))$root
  }
  else if (is.null(sig.level)) 
    sig.level <- uniroot(function(sig.level) eval(p.body) - 
                           power, c(1e-10, 1 - 1e-10))$root
  else stop("internal error")
  NOTE <- switch(type, paired = "n is number of *pairs*", 
                 two.sample = "n is number in *each* group", NULL)
  METHOD <- paste(switch(type, one.sample = "One-sample", 
                         two.sample = "Two-sample", paired = "Paired"), "t test power calculation")
  structure(list(n = n, d = d, sig.level = sig.level, power = power, 
                 alternative = alternative, note = NOTE, method = METHOD), 
            class = "power.htest")
}