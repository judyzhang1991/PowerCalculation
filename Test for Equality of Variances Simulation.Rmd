---
title: "Test for Equality of Variances Simulation"
author: "Jingyang(Judy) Zhang"
date: "10/6/2021"
output: html_document
---



```{r load_pkgs}

library(tidyverse)
library(skimr)

```




# A. Simulation 


Set Seed:

```{r set_seed}
set.seed(990970215)
```


Assume population parameters are given below:

Control Group: $N_X$, $n_X$, $X\sim N(\mu_X, \sigma_X^2)$.

Treatment Group: $N_Y$, $n_Y$, $Y\sim N(\mu_Y, \sigma_Y^2)$.



Function generate_N_sample: Generate sample data (with sample variance and sample means) for the control group and the treatment group, that is to randomly sample nX and nY observations from the control group population/distribution and the treatment group population/distribution, respectively.  

Arguments: 

N: total number of samples of size nX and nY to generate for the control group and the treatment group. 

nX, nY: sample sizes.

sigmaX, sigmaY: population standard deviations.

muX, muY: population means.

distX, distY: population distributions with default values set to "normal".

"normal" - the normal distribution.

Return: 

X_samples, X_sample_means, X_sample_sds, Y_samples, Y_sample_means, Y_sample_sds: generated sample observations (with sample means and sample variances) for the control group and the treatment group. 


```{r generate_N_sample}

generate_N_sample <- function(N, nX, nY, sigmaX, sigmaY, muX, muY, distX = "normal", distY = "normal"){
  
  X_samples <- list()
  
  X_sample_means <- c()
  
  X_sample_sds <- c()
  
  Y_samples <- list()
  
  Y_sample_means <- c()
  
  Y_sample_sds <- c()
  

  
  if(distX == "normal"){
    
    for(i in 1:N){
      
      X_sample <- rnorm(nX, mean = muX, sd = sigmaX)
      
      X_samples[[i]] <- X_sample
      
      X_sample_means[i] <- mean(X_sample)
      
      X_sample_sds[i] <- sd(X_sample)
      
    }
    
  }
  
   if(distY == "normal"){
     
      for(i in 1:N){
      
      Y_sample <- rnorm(nY, mean = muY, sd = sigmaY)
      
      Y_samples[[i]] <- Y_sample
      
      Y_sample_means[i] <- mean(Y_sample)
      
      Y_sample_sds[i] <- sd(Y_sample)
      
    }
    
   }
  
  return(list("X_samples" = X_samples, "X_sample_means" = X_sample_means, "X_sample_sds" = X_sample_sds, "Y_samples" = Y_samples, "Y_sample_means" = Y_sample_means, "Y_sample_sds" = Y_sample_sds))
  
}

```



Generate Sample Data
```{r run_gen_N_sample}


# Parameter Sets: 10000 samples of size 30 for the control group and for the treatment group 

N <- 10000

nX <- 30
nY <- 30
sigmaX <- 1
sigmaY <- 1.5
muX <- 0
muY <- 0
distX <- "normal"
distY <- "normal"


N_samples <- generate_N_sample(N, nX, nY, sigmaX, sigmaY, muX, muY, distX, distY)

X_samples <- N_samples$X_samples

X_sample_means <- N_samples$X_sample_means

X_sample_sds <- N_samples$X_sample_sds


Y_samples <- N_samples$Y_samples

Y_sample_means <- N_samples$Y_sample_means

Y_sample_sds <- N_samples$Y_sample_sds


######### EDA OF SAMPLES ###########
summary(X_sample_means)
summary(Y_sample_means)

summary(X_sample_sds)
summary(Y_sample_sds)



```




B.Statistical Test


Function run_N_stat_test: run statistical test (with decisions) on each of N pairs of the control group samples of size nX and the treatment group samples of size nY. 

Arguments: 

nX, nY: sample sizes.

X_sample_means, Y_sample_means: lists of N samples means calculated for each sample of size nX or nY for the control group or the treatment group. 

X_sample_sds, Y_sample_sds: lists of N samples sds calculated for each sample of size nX or nY for the control group or the treatment group. 

test: type of test with default to be the F ratio test. 
"F" - the F ratio test. 
"L" - the Levene's test. 

side: determine one-sided or two-sided test. 
1 - One sided test (upper or lower will be determined by sample variances).
Lower One-Sided Test: 
$H_a: \sigma_X^2 <\sigma_Y^2\Rightarrow\frac{\sigma_X^2}{\sigma_Y^2} < 1$
Upper One-Sided Test:
$H_a: \sigma_X^2 >\sigma_Y^2\Rightarrow\frac{\sigma_X^2}{\sigma_Y^2} > 1$
2 - Two sided test.
$H_a: \sigma_X^2 \neq \sigma_Y^2\Rightarrow \frac{\sigma_X^2}{\sigma_Y^2}\neq 1$.

Return: 
F_stats: a total of N observed F ratio statistics. 
test_decisions: a list of test result with 1 meaning reject $H_0$ and 0 means fail to reject $H_0$. 

```{r run_N_stat_test}

run_N_stat_test <- function(nX, nY, X_sample_means, X_sample_sds, Y_sample_means, Y_sample_sds, test, side){
  
  # Conduct F Ratio Test
  if(test == "F"){
    
    F_stats <- X_sample_sds/Y_sample_sds
    
    test_descisions <- c()
    
    
    # Conduct One Sided Test
    if(side == 1){
        F_crit_low <- qf(alpha, nX-1, nY-1, lower.tail = TRUE, log.p = FALSE)
    
        F_crit_up <- qf(1-alpha, nX-1, nY-1, lower.tail = TRUE, log.p = FALSE)
        
      for(i in 1:length(F_stats)){
        
        # Conduct lower one sided test
        if(X_sample_sds[i] <= Y_sample_sds[i]){
          
          test_descisions[i] <- ifelse(F_stats[i] <= F_crit_low, 1, 0)
          
        }
        
        # Conduct upper one sided test
        else{
          
          test_descisions[i] <- ifelse(F_stats[i] >= F_crit_up, 1, 0)
          
        }
        
      }
      
    }
    
    
    # Conduct Two Sided Test
    if(side == 2){
      
      F_crit_twolow <- qf(alpha/2, nX-1, nY-1, lower.tail = TRUE, log.p = FALSE)
    
      F_crit_twoup <- qf(1-alpha/2, nX-1, nY-1, lower.tail = TRUE, log.p = FALSE)
      
      for(i in 1:length(F_stats)){
        
        test_descisions[i] <- ifelse((F_stats[i] <= F_crit_twolow | F_stats[i] >= F_crit_twoup), 1, 0)
      }
    }
    
  }
  
  return(list("F_stats" = F_stats, "test_decisions" = test_descisions))
  
}

```


Run F Ratio Test for Two Equal Variances
```{r run_run_N_stat_test}

alpha <- 0.05

test <- "F"

side <- 1

tests <- run_N_stat_test(nX, nY, X_samples_means, X_sample_sds, Y_sample_means, Y_sample_sds, test, side)

F_stats <- tests$F_stats

test_descisions <- tests$test_decisions


####### EDA OF TEST RESULTS #####

sum(test_descisions)

```



Calculate Power for F Ratio Test for Two Equal Variances
```{r}
# Empirical Power

emp_power <- sum(test_descisions)/N

emp_power


# Theoretical Power

## Lower One Sided Test
F_crit_low <- qf(alpha, nX-1, nY-1, lower.tail = TRUE, log.p = FALSE)

# See qf function documentation
ncp <- muX^2 + muY^2

theo_power_low <- pf(F_crit_low, nX-1, nY-1, ncp = ncp, lower.tail = TRUE, log.p = FALSE)

theo_power_low


## Upper One Sided Test
F_crit_up <- qf(1-alpha, nX-1, nY-1, lower.tail = TRUE, log.p = FALSE)


theo_power_up <- pf(F_crit_up, nX-1, nY-1, ncp = ncp, lower.tail = FALSE, log.p = FALSE)

theo_power_up


## Two Sided Test
F_crit_twolow <- qf(alpha/2, nX-1, nY-1, lower.tail = TRUE, log.p = FALSE)

theo_power_twolow <- pf(F_crit_twolow, nX-1, nY-1, lower.tail = TRUE, log.p = FALSE)

F_crit_twoup <- qf(1-alpha/2, nX-1, nY-1, lower.tail = TRUE, log.p = FALSE)


theo_power_twoup <- pf(F_crit_twoup, nX-1, nY-1, ncp = ncp, lower.tail = FALSE, log.p = FALSE)


theo_power_two <- theo_power_twolow + theo_power_twoup

theo_power_two



```


Plot Null and Alternative F Distributions
```{r}
x <- rf(100000, df1 = nX-1, df2 = nY-1)
y <- rf(100000, df1 = nX-1, df2 = nY-1, ncp = ncp)
hist(x, 
     breaks = 'Scott', 
     freq = FALSE, 
     xlim = c(0,3), 
     ylim = c(0,2),
     xlab = '', 
     main = ("Histogram of F Distribution"), cex.main=0.9)

hist(y, 
     breaks = 'Scott', 
     add = TRUE,
     freq = FALSE,
     col = "red")

curve(df(x, df1 = nX-1, df2 = nY-1), from = 0, to = 4, n = 5000, col= 'pink', lwd=2, add = TRUE)

curve(df(y, df1 = nX-1, df2 = nY-1, ncp = ncp), from = 0, to = 4, n = 5000, col= 'pink', lwd=2, add = TRUE)

```

